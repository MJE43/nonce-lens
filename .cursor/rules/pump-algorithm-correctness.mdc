---
globs: *.py,pump.py,test_*.py
description: Critical algorithm implementation details for Pump provably-fair determinism
---

# Pump Algorithm Implementation - Critical Correctness Requirements

## HMAC Key and Message Construction (CRITICAL)
```python
# CORRECT: Use server seed as ASCII string (as displayed by Stake)
key = server_seed.encode('utf-8')  # DO NOT hex-decode the server seed!

# CORRECT: Message format with colon separators
message = f"{client_seed}:{nonce}:{round}"  # round ∈ {0,1,2,...}

# Generate digest
digest = hmac.new(key, message.encode('utf-8'), hashlib.sha256).digest()
```

## Float Generation from Bytes (CRITICAL)
```python
# CORRECT: Process digest in 4-byte chunks
for i in range(0, len(digest), 4):
    if i + 4 <= len(digest):
        b0, b1, b2, b3 = digest[i:i+4]
        # CRITICAL: Use exact rational arithmetic
        u = b0/256 + b1/256**2 + b2/256**3 + b3/256**4
        # u ∈ [0,1) - u==1 cannot occur with SHA256 output
```

## Selection Shuffle Algorithm (CRITICAL)
```python
pool = list(range(1, 26))  # [1, 2, 3, ..., 25]
permutation = []

for u in generated_floats:
    if len(permutation) == 25:
        break
    j = int(u * len(pool))  # floor(u * len(pool))
    pick = pool.pop(j)      # Remove from pool at index j
    permutation.append(pick)
```

## Pump Mapping Logic (CRITICAL)
```python
# Difficulty -> M (number of POP tokens)
M_VALUES = {"easy": 1, "medium": 3, "hard": 5, "expert": 10}

M = M_VALUES[difficulty]
pops = permutation[:M]          # First M positions
pop_point = min(pops)           # 1-based minimum
safe_pumps = min(pop_point - 1, 25 - M)
multiplier = MULTIPLIER_TABLE[difficulty][safe_pumps]
```

## Multiplier Tables (MUST VALIDATE)
```python
# Table lengths MUST equal (25 - M + 1) for each difficulty
# Validate at import time and fail fast if mismatched

EASY_TABLE = [1.00, 1.02, 1.06, ...]     # 25 values (M=1, 25-1+1=25)
MEDIUM_TABLE = [1.00, 1.11, 1.27, ...]   # 23 values (M=3, 25-3+1=23)
HARD_TABLE = [1.00, 1.23, 1.55, ...]     # 21 values (M=5, 25-5+1=21)
EXPERT_TABLE = [1.00, 1.63, 2.80, ...]   # 16 values (M=10, 25-10+1=16)

# Validation
assert len(EASY_TABLE) == 25
assert len(MEDIUM_TABLE) == 23
assert len(HARD_TABLE) == 21
assert len(EXPERT_TABLE) == 16
```

## Golden Test Vector (MUST PASS)
```python
def test_golden_vector():
    server = "564e967b90f03d0153fdcb2d2d1cc5a5057e0df78163611fe3801d6498e681ca"
    client = "zXv1upuFns"
    nonce = 5663
    difficulty = "expert"

    result = verify_pump(server, client, nonce, difficulty)
    assert abs(result["max_multiplier"] - 11200.65) < 1e-9
```

## Target Matching Tolerance
```python
ATOL = 1e-9  # Absolute tolerance for floating-point comparisons

def is_target_hit(multiplier: float, target: float) -> bool:
    return abs(multiplier - target) <= ATOL
```

## Engine Version Tracking
```python
ENGINE_VERSION = "pump-1.0.0"  # Export for traceability
```
